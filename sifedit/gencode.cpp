
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "sifedit.h"
#include "gencode.fdh"

static uint32_t hash;

void accum_hash(const char *str);
void accum_hash(char ch);

// sprites.h: a simple .h file which declares constants for all the sprites in the sif
bool generate_sprites_h(const char *fname)
{
	DString output;
	init_hash();
	
	int nsprites = spritelist.CountItems();
	for(int i=0;i<nsprites;i++)
	{
		DString str("#define ");
		str.AppendString(GetSpriteHeaderName(spritelist.SpriteAt(i)->Name()));
		str.AppendString("\t\t");
		str.AppendString(stprintf("%d", i));
		
		output.AppendString(str.String());
		output.AppendString("\n");
		
		accum_hash(str.String());
	}
	
	return write_file_if_needed(&output, fname, __FUNCTION__);
}

// AssignSprites.cpp: provides a function AssignSprites(), which assigns sprites
// to object types that have the same names as the sprite save for their
// OBJ_ instead of _SPR prefix.
bool generate_assignsprites_cpp(const char *fname)
{
char line[1024];

	StringList objtypes;
	if (read_list_of_objtypes("../object.h", &objtypes))
		return 1;
	
	DString output;
	init_hash();
	
	output.AppendString("#include \"../nx.h\"\n"
						"#include \"sprites.h\"\n"
						"\n"
						"void AssignSprites(void)\n"
						"{\n"
						);
	
	int nsprites = spritelist.CountItems();
	for(int i=0;i<nsprites;i++)
	{
		const char *sprname = GetSpriteHeaderName(spritelist.SpriteAt(i)->Name());
		sprname += 4;	// skip SPR_
		
		if (objtypes.ContainsString(sprname))
		{
			sprintf(line, "\tobjprop[OBJ_%s].sprite = SPR_%s;\n", sprname, sprname);
			accum_hash(line);
			output.AppendString(line);
		}
	}

	output.AppendString("}\n\n");
	
	return write_file_if_needed(&output, fname, __FUNCTION__);
}


static bool read_list_of_objtypes(const char *hfile, StringList *names)
{
FILE *fp;
char line[1024];

	fp = fopen(hfile, "rb");
	if (!fp)
	{
		staterr("read_list_of_objtypes: couldn't open engine source file '%s'", hfile);
		return 1;
	}
	
	while(!feof(fp))
	{
		fgetline(fp, line, sizeof(line));
		
		// search for object definitions
		if (line[0]=='#' && strbegin(line+1, "define"))
		{
			char *name;
			if ((name = strstr(line, "OBJ_")))
			{
				name += 4;			// trim off OBJ_ prefix
				
				// trim "name" at first tab or space (in case there is a comment, etc)
				char *ptr = strpbrk(name, " \t/");
				if (ptr) *ptr = 0;
				
				names->AddString(name);
			}
		}
	}
	
	fclose(fp);
	return 0;
}

/*
void c------------------------------() {}
*/

bool write_file_if_needed(DString *str, const char *fname, const char *funcname)
{
	if (read_hash(fname) != hash)	// avoid triggering unnecessary "make"-based recompilation
	{
		FILE *fp = fopen(fname, "wb");
		if (!fp)
		{
			staterr("%s('%s'): cannot open file", funcname, fname);
			return 1;
		}
		
		stat("regenerating file %s", fname);
		
		fprintf(fp, "//hash: %08x\n", hash);
		fprintf(fp, "//auto-generated by sifedit %s\n\n", get_timestamp());
		
		fprintf(fp, "%s\n", str->String());
		fclose(fp);
	}
	
	return 0;
}

/*
void c------------------------------() {}
*/

static void init_hash()
{
	hash = 0xac4279ae;
}

static void accum_hash(const char *str)
{
	for(int i=0;str[i];i++)
		accum_hash(str[i]);
}

static void accum_hash(char ch)
{
uint32_t msb;

	// no particular math here at all. it's pretty much just random mangling.
	msb = (hash >> 24);
	hash <<= 3;
	hash += 3;
	hash ^= ch;
	hash ^= msb;
	
	// don't allow 0 because that's whats returned by read_hash on an error
	if (hash == 0)
		hash++;
}

static uint32_t read_hash(const char *fname)
{
FILE *fp;
char line[1024];

	fp = fopen(fname, "rb");
	if (!fp) return 0;
	
	fgetline(fp, line, sizeof(line));
	fclose(fp);
	
	if (!strbegin(line, "//hash: ")) return 0;
	return strtol(line+8, NULL, 16);
}

static const char *get_timestamp()
{
char *str = GetStaticStr();
time_t curtime = time(NULL);
	
	strftime(str, 32, "%a %d %Y  %I:%M:%S%p", localtime(&curtime));
	return str;
}

